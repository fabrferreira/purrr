[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Utilizando as ferramentas de programação funcional no R",
    "section": "",
    "text": "Programação funcional, basicamente, é um conjunto de ferramentas que nos permite usar funções e iterações a fim de simplificar operações morosas e complexas. Aqui, eu simplifiquei bastante, pois, a depender da implementação que o usuário está realizando, a programação funcional pode abarcar muito mais do que aqui foi dito.\nNesse documento, irei mostrar uma simples aplicação do uso de programação funcional utilizando o R. Para fazer isso, nada mais adequado do que utilizar o pacote purrr criado por Hadley Wickham. Este pacote é maravilhoso e, além de fornecer uma conjunto de funções estáveis no que se refere à tipagem, isto é, o usuário sabe exatamente qual será o tipo de objeto de saída. Além do purrr, estaremos utilizando os pacotes dplyr, tidyr and ggplot2 e janitor.\nA tarefa que executaremos neste documento trata-se de responder uma questão de um exercício da disciplina de Econometria do Doutorado em Economia da UFBA que é, basicamente, uma atividade de simulação de amostras de uma distribuição binomial. A atividade pede que o aluno simule uma distribuição binomial segundo os parâmetros dados no enunciado. A complexidade da atividade, em si, consiste nos subitens da questão, onde se pede que sejam geradas cerca de 200 amostras aleatórias da distribuição com, cada uma delas, sendo composta de 100 observações. Sem saber programação funcional, nosso código atingiria proporções descomunais, sem contar o fato da eficiência e legibilidade. Contudo, como veremos, utilizar programação funcional torna esse processo muito mais eficiente.\n\n\n\n\n\nAntes de mais nada, devemos carregar os pacotes necessários para executar esta tarefa.\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(janitor)\n\n# Para assegurar a replicabilidade de nossos resultados, vamos configurar uma `random.seed`.\nset.seed(2023)\n\nCom os pacotes carregados, nós podemos utilizar a função map() do pacote purrr conjugando-a com a função rbinom do R base. A função map() permite que executemos iterações em uma forma muito mais eficiente que os famosos loops for. Executamos a iteração e armazenamos os resultados em um objeto chamado df_binom. Essa operação responde ao item 1 da questão.\n\ndf_binom &lt;- purrr::map(1:200, ~purrr::map(1, ~rbinom(n = 100, size = 4, prob = 0.25))) |&gt;  \n  dplyr::bind_cols() |&gt; \n  janitor::clean_names() \n\nA partir do objeto bin_sample, podemos utilizar novamente uma variante da função map, map_dbl() para extrair a média de cada uma das amostras e armazená-las em um outro objeto chamado binom_mean. Nós poderíamos, sem perda de eficiência, encadear essas duas operações em uma única chamada do pipe. Contudo, para fins didáticos, optei por separar essas duas operações. Esta operação responde ao item 2 da questão 1.\n\nbinom_mean &lt;- df_binom |&gt; \n  purrr::map_dbl(mean)\n\nPor fim, a partir do objeto binom_mean, podemos transformar as médias extraídas em um gráfico, respondendo, assim, ao item 3 da questão 1. Nós implementamos uma função anônima na chamada da variante map, map_df, e pivotamos o objeto resultante para que fique mais fácil a geração do gráfico da distribuição.\n\nbinom_mean |&gt; \n  purrr::map_df(.x = _, .f = \\(.data) sqrt(100) * (.data - 1) / 0.866 ) |&gt; \n  tidyr::pivot_longer(\n    cols = everything(), \n    names_to = \"variable\", \n    values_to = \"value\"\n    ) |&gt; \n  ggplot2::ggplot(aes(value))+\n  ggplot2::geom_density(fill = \"darkred\")\n\n\n\n\nCom esse simples script, respondemos a questão de simulação de amostras de uma distribuição binomial, mostrando de uma forma elegante o poder do pacote purrr. Sem dominar o purrr teríamos duas alternativas: utilizar loops, que não são eficientes; ou criar diversos objetos intermediários para cada amostra, o que deixaria nosso código nada legível."
  },
  {
    "objectID": "index.html#programação-funcional",
    "href": "index.html#programação-funcional",
    "title": "Utilizando as ferramentas de programação funcional no R",
    "section": "",
    "text": "Programação funcional, basicamente, é um conjunto de ferramentas que nos permite usar funções e iterações a fim de simplificar operações morosas e complexas. Aqui, eu simplifiquei bastante, pois, a depender da implementação que o usuário está realizando, a programação funcional pode abarcar muito mais do que aqui foi dito.\nNesse documento, irei mostrar uma simples aplicação do uso de programação funcional utilizando o R. Para fazer isso, nada mais adequado do que utilizar o pacote purrr criado por Hadley Wickham. Este pacote é maravilhoso e, além de fornecer uma conjunto de funções estáveis no que se refere à tipagem, isto é, o usuário sabe exatamente qual será o tipo de objeto de saída. Além do purrr, estaremos utilizando os pacotes dplyr, tidyr and ggplot2 e janitor.\nA tarefa que executaremos neste documento trata-se de responder uma questão de um exercício da disciplina de Econometria do Doutorado em Economia da UFBA que é, basicamente, uma atividade de simulação de amostras de uma distribuição binomial. A atividade pede que o aluno simule uma distribuição binomial segundo os parâmetros dados no enunciado. A complexidade da atividade, em si, consiste nos subitens da questão, onde se pede que sejam geradas cerca de 200 amostras aleatórias da distribuição com, cada uma delas, sendo composta de 100 observações. Sem saber programação funcional, nosso código atingiria proporções descomunais, sem contar o fato da eficiência e legibilidade. Contudo, como veremos, utilizar programação funcional torna esse processo muito mais eficiente.\n\n\n\n\n\nAntes de mais nada, devemos carregar os pacotes necessários para executar esta tarefa.\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(janitor)\n\n# Para assegurar a replicabilidade de nossos resultados, vamos configurar uma `random.seed`.\nset.seed(2023)\n\nCom os pacotes carregados, nós podemos utilizar a função map() do pacote purrr conjugando-a com a função rbinom do R base. A função map() permite que executemos iterações em uma forma muito mais eficiente que os famosos loops for. Executamos a iteração e armazenamos os resultados em um objeto chamado df_binom. Essa operação responde ao item 1 da questão.\n\ndf_binom &lt;- purrr::map(1:200, ~purrr::map(1, ~rbinom(n = 100, size = 4, prob = 0.25))) |&gt;  \n  dplyr::bind_cols() |&gt; \n  janitor::clean_names() \n\nA partir do objeto bin_sample, podemos utilizar novamente uma variante da função map, map_dbl() para extrair a média de cada uma das amostras e armazená-las em um outro objeto chamado binom_mean. Nós poderíamos, sem perda de eficiência, encadear essas duas operações em uma única chamada do pipe. Contudo, para fins didáticos, optei por separar essas duas operações. Esta operação responde ao item 2 da questão 1.\n\nbinom_mean &lt;- df_binom |&gt; \n  purrr::map_dbl(mean)\n\nPor fim, a partir do objeto binom_mean, podemos transformar as médias extraídas em um gráfico, respondendo, assim, ao item 3 da questão 1. Nós implementamos uma função anônima na chamada da variante map, map_df, e pivotamos o objeto resultante para que fique mais fácil a geração do gráfico da distribuição.\n\nbinom_mean |&gt; \n  purrr::map_df(.x = _, .f = \\(.data) sqrt(100) * (.data - 1) / 0.866 ) |&gt; \n  tidyr::pivot_longer(\n    cols = everything(), \n    names_to = \"variable\", \n    values_to = \"value\"\n    ) |&gt; \n  ggplot2::ggplot(aes(value))+\n  ggplot2::geom_density(fill = \"darkred\")\n\n\n\n\nCom esse simples script, respondemos a questão de simulação de amostras de uma distribuição binomial, mostrando de uma forma elegante o poder do pacote purrr. Sem dominar o purrr teríamos duas alternativas: utilizar loops, que não são eficientes; ou criar diversos objetos intermediários para cada amostra, o que deixaria nosso código nada legível."
  }
]